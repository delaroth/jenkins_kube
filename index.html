<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Subtle Revelation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for the page's overall appearance and animations */
        body {
            /* Set font to Inter, with sans-serif as a fallback */
            font-family: 'Inter', sans-serif;
            margin: 0; /* Remove default body margin */
            overflow: hidden; /* Hide scrollbars, as elements are positioned absolutely */
            background-color: #0d1117; /* A dark, almost black background for a cosmic feel */
            display: flex; /* Use flexbox to center the initial hidden message */
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            cursor: default; /* Default cursor */
            position: relative; /* Needed for absolute positioning of child elements */
        }

        /* Styling for the hidden message that appears after transformation */
        #hiddenMessage {
            position: absolute; /* Position relative to the body */
            color: #ffffff; /* White text for contrast */
            font-size: 2.5rem; /* Base font size, responsive classes will override */
            font-weight: 700; /* Bold text */
            opacity: 0; /* Initially invisible */
            transform: translateY(20px); /* Start slightly below its final position */
            /* Smooth transition for opacity and transform when revealed */
            transition: opacity 2s ease-in-out, transform 2s ease-in-out;
            text-align: center; /* Center the text */
            padding: 20px; /* Padding around the message */
            background: rgba(0, 0, 0, 0.5); /* Semi-transparent dark background */
            border-radius: 1rem; /* Rounded corners for the message box */
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5); /* A subtle cyan glow effect */
            z-index: 100; /* Ensure the message is on top of other elements */
            /* Responsive font sizes using Tailwind utility classes */
            @apply text-4xl md:text-5xl lg:text-6xl;
        }

        /* Class added by JavaScript to reveal the message */
        #hiddenMessage.revealed {
            opacity: 1; /* Fully visible */
            transform: translateY(0); /* Move to its final position */
        }

        /* Base styles for the dynamically created "universe" elements */
        .universe-element {
            position: absolute; /* Allows precise positioning */
            border-radius: 1rem; /* Apply rounded corners to all elements by default */
            /* Smooth transitions for hover effects (transform and background color) */
            transition: transform 0.1s ease-out, background-color 0.3s ease-out;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2); /* Subtle white glow */
            will-change: transform, opacity; /* Optimize browser rendering for these properties */
        }

        /* Hover effect for the universe elements */
        .universe-element:hover {
            transform: scale(1.2) rotate(10deg); /* Grow and slightly rotate on hover */
            z-index: 99; /* Bring the hovered element to the front */
        }

        /* Keyframe animation for the initial staggered appearance of elements */
        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0); } /* Start invisible and tiny */
            to { opacity: 1; transform: scale(1); } /* End fully visible and at normal size */
        }

        /* Class applied to elements for their initial fade-in and scale animation */
        .fade-in-scale {
            animation: fadeInScale 1s ease-out forwards; /* Apply the animation */
        }
    </style>
</head>
<body>
    <div id="hiddenMessage">
        The universe unfolds for those who observe.
    </div>

    <script>
        // Ensure the Inter font is applied to the document's root element
        document.documentElement.style.fontFamily = "'Inter', sans-serif";

        // Get references to key DOM elements
        const body = document.body;
        const hiddenMessage = document.getElementById('hiddenMessage');

        // State variables
        let isTransformed = false; // Flag to ensure transformation happens only once
        let elementsArray = []; // Array to store properties of dynamic elements
        const numElements = 50; // Number of dynamic elements to create

        // Predefined color palette for the elements using Tailwind CSS background classes
        const colors = [
            'bg-blue-500', 'bg-purple-500', 'bg-pink-500', 'bg-teal-500',
            'bg-yellow-500', 'bg-red-500', 'bg-green-500', 'bg-indigo-500'
        ];
        // Predefined shapes using Tailwind CSS border-radius classes
        const shapes = ['rounded-full', 'rounded-lg', '']; // Circle, rounded square, square (no specific rounded class means default square with 1rem border-radius from .universe-element)

        // Mouse coordinates, initialized to the center of the window
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;

        /**
         * Generates a random integer within a specified range (inclusive).
         * @param {number} min - The minimum value.
         * @param {number} max - The maximum value.
         * @returns {number} A random integer.
         */
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * Generates a random floating-point number within a specified range.
         * @param {number} min - The minimum value.
         * @param {number} max - The maximum value.
         * @returns {number} A random float.
         */
        function getRandomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        /**
         * Initiates the page transformation, creating and animating the "universe" elements.
         */
        function transformPage() {
            // If already transformed, exit to prevent re-triggering
            if (isTransformed) return;
            isTransformed = true; // Set flag to true

            // Remove the initial event listeners from the body
            body.removeEventListener('mousemove', transformPage);
            body.removeEventListener('click', transformPage);

            // Loop to create and append dynamic elements to the body
            for (let i = 0; i < numElements; i++) {
                const element = document.createElement('div'); // Create a new div element
                const size = getRandomInt(20, 80); // Random size for the element (20px to 80px)
                const color = colors[getRandomInt(0, colors.length - 1)]; // Random color from the palette
                const shape = shapes[getRandomInt(0, shapes.length - 1)]; // Random shape

                // Apply Tailwind classes and custom classes for styling
                element.className = `universe-element ${color} ${shape} w-[${size}px] h-[${size}px] fade-in-scale`;
                // Set initial random position within the window bounds
                element.style.left = `${getRandomInt(0, window.innerWidth - size)}px`;
                element.style.top = `${getRandomInt(0, window.innerHeight - size)}px`;
                element.style.opacity = '0'; // Start invisible for the fade-in animation
                // Stagger the animation start time for a more organic appearance
                element.style.animationDelay = `${i * 0.05}s`;

                body.appendChild(element); // Add the element to the body

                // Store element properties for use in the animation loop
                elementsArray.push({
                    el: element, // Reference to the DOM element
                    x: parseFloat(element.style.left), // Current X position
                    y: parseFloat(element.style.top), // Current Y position
                    vx: getRandomFloat(-0.5, 0.5), // Velocity in X direction
                    vy: getRandomFloat(-0.5, 0.5), // Velocity in Y direction
                    size: size, // Size of the element
                    initialOpacity: getRandomFloat(0.5, 1) // Random initial opacity after fade-in
                });
            }

            // Reveal the hidden message after a delay, allowing elements to appear first
            setTimeout(() => {
                hiddenMessage.classList.add('revealed'); // Add class to trigger reveal animation
            }, numElements * 50 + 1000); // Delay based on number of elements + 1 second buffer
            
            // Start the main animation loop for the universe elements
            animateUniverse();
        }

        /**
         * The main animation loop for the floating universe elements.
         * Uses requestAnimationFrame for smooth animations.
         */
        function animateUniverse() {
            elementsArray.forEach(item => {
                const el = item.el; // Current DOM element

                // Update element's position based on its velocity
                item.x += item.vx;
                item.y += item.vy;

                // Boundary collision detection: Bounce elements off the window edges
                if (item.x + item.size > window.innerWidth || item.x < 0) {
                    item.vx *= -1; // Reverse X velocity
                    // Adjust position to prevent sticking to the edge
                    item.x = Math.max(0, Math.min(item.x, window.innerWidth - item.size));
                }
                if (item.y + item.size > window.innerHeight || item.y < 0) {
                    item.vy *= -1; // Reverse Y velocity
                    // Adjust position to prevent sticking to the edge
                    item.y = Math.max(0, Math.min(item.y, window.innerHeight - item.size));
                }

                // Mouse interaction: Apply a subtle repulsion/attraction force
                // Calculate distance from element center to mouse cursor
                const dx = item.x + item.size / 2 - mouseX;
                const dy = item.y + item.size / 2 - mouseY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const repulsionRadius = 150; // Radius within which mouse interaction occurs

                if (distance < repulsionRadius) {
                    // Calculate force strength: stronger when closer to the mouse
                    const force = (repulsionRadius - distance) / repulsionRadius * 0.1;
                    // Apply force to velocities, pushing elements away from the mouse
                    item.vx += dx * force * 0.05;
                    item.vy += dy * force * 0.05;
                }

                // Dampen velocity slightly to prevent elements from accelerating infinitely
                item.vx *= 0.99;
                item.vy *= 0.99;

                // Apply the updated position to the element using CSS transform for performance
                el.style.transform = `translate(${item.x}px, ${item.y}px)`;
                // Maintain the initial opacity after the fade-in animation completes
                el.style.opacity = item.initialOpacity;
            });

            // Request the next animation frame for continuous animation
            requestAnimationFrame(animateUniverse);
        }
…</html>
